# javaSpringBootBasic2

## Spring boot와 객체 지향 언어에 대한 개념 정리와 실습


+ Spring의 핵심

<br>




- 스프링은 자바 언어 기반의 프레임워크

- 자바의 가장 큰 특징 - 객체 지향 언어

- 객체 자향 언어가 가진 강력한 특징을 살려내는 프레임워크

- 좋은 객체 지향 애플리케이션을 개발할 수 있는 프레임워크



+ 객체 지향 특징


- 추상화 :
> 객체들의 공통적인 특징을 도출

> 객체 지향적 관점에서는 클래스를 정의하는 것을 추상화라고 할 수 있음


- 캡슐화 :

> 실제로 구현되는 부분을 외부에 드러나지 않도록 하여 정보를 은닉

> 객체가 독립적으로 역할을 할 수 있도록 데이터와 기능을 하나로 묶어 관리하는 것




- 상속 :

> 하나의 클래스가 가진 특징(함수, 데이터)을 다른 클래스가 그대로 물려받는 것

> 이미 작성된 클래스를 받아서 새로운 클래스를 생성하는 것

> 기존 코드를 재활용해서 사용함으로써 객체지향 방법의 중요한 기능 중 하나에 속한다





- 다형성 :

> 같은 자료형에 여러 가지 객체를 대입하여 다양한 결과를 얻어내는 성질

> 하나의 타입으로 다양한 실행 결과를 얻을 수 있으며 객체를 부품화 하여 유지 보수를 용이하게 함



+ 오버라이딩(Overriding), 오버로딩(Overloading)


> 오버라이딩(Overriding) - 부모클래스의 메소드와 같은 이름을 사용하며 매개변수도 같되 내부 소스를 재정의하는 것

> 오버로딩(Overloading) - 같은 이름의 함수를 여러 개 정의한 후 매개변수를 다르게 하여 같은 이름을 경우에 따라 호출하여 사용하는 것


-> 프로그램을 유연하고 변경을 용이하게 만들어줌


+ 역할과 구현을 분리 


> 역할 = 인터페이스

> 구현 = 인터페이스를 구현한 클래스, 구현 객체





+ 좋은 객체 지향 설계의 5가지 원칙(SOLID)



- SRP: 단일 책임 원칙(SINGLE RESPONSIBILITY PRINCIPLE)

- OCP: 개방 폐쇄 원칙(OPEN/CLOSED PRINCIPLE)

- LSP: 리스코프 치환 원칙(LISKOV SUBSTITUTION PRINCIPLE)

- ISP: 인터페이스 분리 원칙(INTERFACE SEGREGATION PRINCIPLE)

- DIP: 의존관계 역전 원칙(DEPENDENCY INVERSION PRINCIPLE)




- SRP 단일 책임 원칙 (SINGLE RESPONSIBILITY PRINCIPLE)



> 한 클래스는 하나의 책임만 가져야 한다

> 하나의 책임이라는 것은 모호하다.

> 중요한 기준은 변경이다. 변경이 있을 때 파급효과가 적으면 단일책임의 원칙을 잘 따른 것




- OCP 개방 폐쇄 원칙 (OPEN/CLOSED PRINCIPLE)



> 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 함

> 다형성을 활용 -> 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능 구현



- LSP 리스코프 치환 원칙 (LISKOV SUBSTITUTION PRINCIPLE)



> 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

> 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다. 

> ex) 자동차 인터페이스 중 엑셀은 앞으로 가라는 기능, 엑셀 기능이 뒤로 가게 구현된다면 LSP 원칙을 위반



- ISP 인터페이스 분리 원칙 (INTERFACE SEGREGATION PRINCIPLE)



> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다

> ex) 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리

> ex) 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리

> 분리하게 된다면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음



- DIP 의존관계 역전 원칙 (DEPENDENCY INVERSION PRINCIPLE)



> 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나

> 구현 클래스에 의존하지 않고 인터페이스에 의존해야 한다.

> 역할에 의존해야 한다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있음

> 구현체에 의존하게 될 경우 변경이 아주 어려워짐





스프링은 

DI(Dependency Injection): 의존관계 의존성 주입

DI 컨테이너 제공

클라이언트 코드의 변경없이 기능 확장

쉽게 부품을 교체하듯이 개발


### IoC, DI, Container

+ 제어의 역전 IoC(Inversion of Control)

> 기존의 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행, 즉 구현 객체가 프로그램의 제어 흐름을 스스로 조종

> 반면에 AppConfig가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 프로그램의
제어 흐름은 이제 AppConfig가 가져간다. 예를 들어서 OrderServiceImpl 은 필요한 인터페이스들을
호출하지만 어떤 구현 객체들이 실행될지 모른다.

> 프로그램에 대한 제어 흐름에 대한 권한은 모두 AppConfig가 가지고 있다. 심지어 OrderServiceImpl
도 AppConfig가 생성한다. 그리고 AppConfig는 OrderServiceImpl 이 아닌 OrderService
인터페이스의 다른 구현 객체를 생성하고 실행할 수 도 있다. 그런 사실도 모른체 OrderServiceImpl 은
묵묵히 자신의 로직을 실행할 뿐이다.

> 이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)이라
한다.












